Syntax Highlighting in Atom
----------------------------
Atom utilizes [Treesitter](https://tree-sitter.github.io/tree-sitter/)
parsers to keep a concrete syntax tree of your code that it
incrementally updates as you type. A Treesitter grammar can be
generated from a Silver grammar by running Silver with the
`--treesitter-spec` flag followed by the name of your language.
The treesitter spec is output to a text file using the standard
 Treesitter name of `grammar.js`. The exact format of this command is

 `silver [-I grammar directories] --treesitter-spec [language name] [grammar with parser specification]`

 To consolidate the rest of the boiler plate code needed for the process of creating a
 Treesitter parser the script `gen-treesitter-parser` is provided in the scripts directory
 in this repository. This script assumes the `grammar.js` file is in the same directory
 the script is run from. The documentation for this script can be found in the [README](../scripts) of the scripts directory.

 The `gen-treesitter-parser` will add the code for the Treesitter parser to the `generated` directory under your Silver-IDE directory. Many of the examples already built use Makefiles to run the commands. Looking at these may be useful as well.

#### Generating a Treesitter Parser for Oberon0
Thus, to generate a Treesitter parser, we first need to
get the grammar file that Treesitter understands. This is
called `grammar.js` and is generated by Silver when the
`--treesitter-spec` flag is included.

The full parser specification for the Oberon0 language
is located in the `components:L4` grammar. Thus, to
generate the `grammar.js` file, the command

`silver --treesitter-spec oberon0 edu:umn:cs:melt:Oberon0:components:L4`

should be run.

Next, to generate the parser and publish it to the NPM
registry you need to run the `gen-treesitter-parser`
script whose documentation is in the `README` in the
scripts directory. Here is a quick summary of how the script works.
You need to provide two flags
1. `--scope [name]`: the scope in the NPM registry where this package should
be published. This allows name conflicts between users wishing to modify a
parser of the same name.
2. `--lang [name]`: the name of the language the same language name used in
the slide file and the one used with the `--treesitter-spec` flag in Silver.
For example, for Oberon0 we would provide `--lang oberon0`.

Additionally, to publish your parser to the NPM registry you need to include
the `--publish flag`. Also, since this is the first time we are creating
a parser for oberon0 we need to add the `--create` flag. This indicates
that certain things that should only happen at creation should be carried
out. The `--create` flag should be used anytime that a new `grammar.js` file
is generated from Silver.

Thus, the command I would use to build the Treesitter parser after generating
the `grammar.js` file is

`gen-treesitter-parser --scope joeblanchard --lang oberon0 --create --publish`


#### Providing Coloring Information For Atom
To specify how to color code in Atom you need to write a language package
for your language. Luckily all of the boilerplate is taken care of for you.
You just need to specify how to color your terminals. This can be done using
the Specification Language for IDEs or Slide.
This langugage is a declarative
DSL for specifying IDE information including coloring. In Atom specifically,
colors are specified abstractly using an idea they have dubbed "scopes"
and then a user installed theme translates these "scopes" to actual colors.
The list of scopes can be found
 [here](https://macromates.com/manual/en/language_grammars.html) under section 12.4.
 These scopes are used to assign a type of meaning to each terminal.
 For example, the scope `keyword.control` is meant to signify the terminal
 represents a keyword dealing with control flow.

 Thus, let us go to the `Terminals.sv` file in the core of Oberon0 and assign
 coloring information using Slide.

 The first part of a Slide file contains what specification the file belongs
 to. We will call this specification `Oberon0Highlighting`.

 Thus, the first line of the file should be

`specification Oberon0Highlighting;`

The next thing a Slide file requires is what grammar the current
specification is being written for. This allows you to avoid writing fully
qualified names for everything. Thus, we are currently developing for
`edu:umn:cs:melt:Oberon0:core:concreteSyntax` so the line would be

`ide_specification for edu:umn:cs:melt:Oberon0:core:concreteSyntax {  
}`

The next thing we will do is specify properties about the terminals. The
property of particular interest is the `atom_markup_name`. This property
is used to specify the scope this terminal belongs to. Thus, to say the
keyword `WHILE` has the property `atom_markup_name = keyword.control`, you
will write

```
terminal While_kwd {
  atomMarkupName = keyword.control;
};
```
Thus, we will assign terminals relating to flow of control to
 `keyword.control` and operators to `keyword.operator`

A few other scopes we will use will be `constant.numeric` for numbers and
`storage.type` for types.

For ignore terminals an extra property must be stated. Atom uses the
concrete syntax tree to highlight the document so since ignore terminals
do not show up in the concrete syntax tree by default. We must specify that
they be `highlightable` so that they will appear.
Thus, to highlight comments in Oberon0 the specification must include
```
terminal Comment {
  highlightable;
  atomMarkupName = comment.block;
};
```
The entire file specifying coloring for terminals
in the core part of the language is in `slide/HighlightingCore.slide`.

Next we need to specify coloring for the parts of the language that are
"extensions" or those that exist in the `constructs` directory of the
Oberon0 repository. These colorings are provided in
`slide/HighlightingConstructs.slide`. A useful concept that you can see in
use here is the wildcard. Since all terminals in `dataStructures` have to do
with type information, we plan to give all terminals the property
`atom_markup_name = storage.type`. So we can simply write
```
terminal * {
  atomMarkupName = storage.type;
}
```
which will give this property to every terminal in the grammar. This could
have also been used for the control flow subgrammar, but we did not to show
the contrast.

#### Specifying Language Wide Properties
Now that we have specified all the coloring information, we can generate
the language package for Atom that actually handles the highlighting. To do
this we need to first add a few language-wide properties. Namely, we need
to specify the name of the treesitter parser, the language name and the file
extensions that indicate we are editing an Oberon0 file.
Thus, we will add a new specification in `GlobalProperties.slide` with the following
information
```
specification Oberon0Globals;
global ide_specification {
  language_name = oberon0;
  file_extensions = [oberon0];
  treesitter_parser = @joeblanchard/tree-sitter-oberon0;
}
```
After adding these commands, you need to list these new specifications
in the specification file list which should now include `Oberon0LSP`,
 `Oberon0Globals` and `Oberon0Highlighting`.

 #### Updating our Treesitter Parser
When we give a terminal the property `highlightable` we are actually
 changing the parser. This means we need to change the `grammar.js` file.
 To do this we simply run slide with `--treesitter grammar.js` which
 provides the appropriate modifications to the file.

Of course this means we need to re-run the `gen-treesitter-parser` script
to update the copy in the NPM registry.

Luckily, as stated earlier since only 1 copy of the parser needs to be
publsihed to the NPM registry, you are free and recommended to use mine at
`@joeblanchard/tree-sitter-obeorn0`. This just explains how and why in case
you need to do something similar for your own project.


`slide -I slide -treesitter ../Oberon0/grammar.js ideInterface.txt slide/SpecificationList.txt`

Move the `grammar.js` file to the Oberon0 directory and change into that
directory and run

`gen-treesitter-parser --scope joeblanchard --lang oberon0 --publish`

Remember to not include the `--create` flag since we have already created
a parser from this specific `grammar.js` file.

 #### Generating the Atom Language Package
 To generate the language package now all we need to is run slide with
 the following arguments

 `slide -I slide --atom-language-file ideInterface.txt slide/SpecificationList.txt`

Now this should output a file called `oberon0.cson`. The next thing we need
to do is run the `gen-atom-language-package` script to generate the
corresponding Atom language package. This script should be run from the
same directory.

`gen-atom-language-package oberon0 joeblanchard`

Now we should be able to see syntax highlighting in Atom for Oberon0.

Open Atom and use the `sample.oberon0` file to see the highlighting.
